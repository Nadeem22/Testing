public void loadSupervisorNames(HttpSession session, String agencyId) {
    String baseSql = "SELECT distinct(first_name) FROM user_master WHERE user_type in(2,3,5) AND disabled = 'N' ";

    if (agencyId != null) {
        baseSql += " AND agencyId=" + agencyId;
    }

    baseSql += " ORDER BY first_name ASC";

    List<User> supList = jdbcTemplate.query(baseSql, (rs, rowNum) -> {
        User user = new User();
        user.setFirstName(rs.getString("first_name"));
        return user;
    });

    session.setAttribute("supervisorList", supList);
}
public static String getSurfBrand() {
    String brandName = "Surf Excel";
    String sql = "SELECT Field_Data_Name FROM brands Where field_data_id= ?";
    Object[] params = new Object[]{ConstantKeys.SURFEXCELMATIC};

    try {
        brandName = jdbcTemplate.queryForObject(sql, params, String.class);
    } catch (DataAccessException e) {
        e.printStackTrace();
    }

    if(brandName == null) {
        brandName = "Surf Excel";
    }
    return brandName;
}
In this version, we use the queryForObject method of JdbcTemplate because we are querying for a single object, not a list. The String.class passed as the third parameter informs Spring that we are expecting a single String result.

As with the previous method, it's recommended to use prepared statements or parameterized queries to prevent SQL Injection attacks.

The queryForObject method returns null if no data is found, so we check for null after the query and set brandName to "Surf Excel" if necessary.

Also, please note that this method is marked as static, which is generally not



